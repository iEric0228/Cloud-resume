name: 'â˜ï¸ Cloud Resume CI/CD'

# âœ… FIX: Remove automatic triggers, only manual
on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Deployment Action'
        required: true
        default: 'deploy-test-destroy'
        type: choice
        options:
          - 'deploy-test-destroy'
          - 'deploy-test-keep'  
          - 'destroy-only'
      keep_alive_minutes:
        description: 'Keep alive time (minutes) for testing'
        required: false
        default: '5'
        type: string

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.6.0

jobs:
  # Validation job (runs on PRs)
  validate:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
    - name: ðŸš€ Checkout Code
      uses: actions/checkout@v4

    - name: âš¡ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: ðŸ” Validate Everything
      run: |
        # Terraform validation
        cd infra/environments/dev
        terraform init
        terraform validate
        terraform fmt -check
        echo "âœ… Terraform validation passed"
        
        # Website validation
        cd ../../../
        required_files=("website/index.html" "website/css/styles.css" "website/js/visitor-counter.js")
        for file in "${required_files[@]}"; do
          [[ -f "$file" ]] && echo "âœ… $file" || { echo "âŒ Missing $file"; exit 1; }
        done
        echo "âœ… Website files validation passed"

  # Main deploy job (runs on manual dispatch)
  deploy-resume:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
    - name: ðŸš€ Checkout Code
      uses: actions/checkout@v4

    - name: âš¡ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        terraform_wrapper: false

    - name: ðŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::125156866057:role/github-OICD
        role-session-name: cloud-resume-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ðŸ—ï¸ Deploy Infrastructure
      if: github.event.inputs.action != 'destroy-only'
      working-directory: ./infra/environments/dev
      run: |
        echo "ðŸš€ Deploying cloud resume infrastructure..."
        terraform init
        
        echo "ðŸ” Checking for existing resources..."
        
        # âœ… ENHANCED: More robust import with state checking
        echo "ðŸ‘¥ Checking IAM role..."
        if terraform state show module.lambda.aws_iam_role.lambda_role 2>/dev/null; then
          echo "âœ… IAM role already in Terraform state"
        elif aws iam get-role --role-name cloud-resume-lambda-role-dev 2>/dev/null; then
          echo "ðŸ“‹ IAM role exists in AWS, importing to Terraform state..."
          terraform import module.lambda.aws_iam_role.lambda_role cloud-resume-lambda-role-dev || {
            echo "âš ï¸ IAM role import failed, will try to recreate"
            # Delete the existing role to allow recreation
            echo "ðŸ—‘ï¸ Removing existing IAM role to allow recreation..."
            aws iam list-attached-role-policies --role-name cloud-resume-lambda-role-dev --query "AttachedPolicies[].PolicyArn" --output text | tr '\t' '\n' | \
            xargs -r -I {} aws iam detach-role-policy --role-name cloud-resume-lambda-role-dev --policy-arn {}
            
            aws iam list-role-policies --role-name cloud-resume-lambda-role-dev --query "PolicyNames" --output text | tr '\t' '\n' | \
            xargs -r -I {} aws iam delete-role-policy --role-name cloud-resume-lambda-role-dev --policy-name {}
            
            aws iam delete-role --role-name cloud-resume-lambda-role-dev
            echo "âœ… Existing IAM role cleaned up"
          }
        else
          echo "ðŸ‘¥ IAM role doesn't exist, will create new one"
        fi
        
        echo "ðŸ“‹ Checking IAM role policy..."
        if terraform state show module.lambda.aws_iam_role_policy.lambda_policy 2>/dev/null; then
          echo "âœ… IAM role policy already in Terraform state"
        elif aws iam get-role-policy --role-name cloud-resume-lambda-role-dev --policy-name cloud-resume-lambda-policy-dev 2>/dev/null; then
          echo "ðŸ“‹ IAM role policy exists, importing to Terraform state..."
          terraform import module.lambda.aws_iam_role_policy.lambda_policy cloud-resume-lambda-role-dev:cloud-resume-lambda-policy-dev || {
            echo "âš ï¸ IAM role policy import failed or already in state"
          }
        else
          echo "ðŸ“‹ IAM role policy doesn't exist, will create new one"
        fi
        
        # Check and import DynamoDB table
        echo "ðŸ“Š Checking DynamoDB table..."
        if terraform state show module.dynamodb.aws_dynamodb_table.visitor_count 2>/dev/null; then
          echo "âœ… DynamoDB table already in Terraform state"
        elif aws dynamodb describe-table --table-name cloud-resume-visitor-count-dev 2>/dev/null; then
          echo "ðŸ“‹ DynamoDB table exists, importing to Terraform state..."
          terraform import module.dynamodb.aws_dynamodb_table.visitor_count cloud-resume-visitor-count-dev || {
            echo "âš ï¸ Table import failed or already in state"
          }
        else
          echo "ðŸ“‹ DynamoDB table doesn't exist, will create new one"
        fi
        
        # Plan and apply
        echo "ðŸ“‹ Planning deployment..."
        terraform plan
        terraform apply -auto-approve
        
        echo "ðŸ” Debug: Available Terraform outputs:"
        terraform output || echo "âŒ No outputs available"
        
        # Export outputs with better error handling
        S3_BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
        WEBSITE_URL=$(terraform output -raw website_url 2>/dev/null || echo "")  
        API_URL=$(terraform output -raw api_url 2>/dev/null || echo "")
        
        echo "ðŸ” Debug: Extracted values:"
        echo "S3_BUCKET='$S3_BUCKET'"
        echo "WEBSITE_URL='$WEBSITE_URL'"
        echo "API_URL='$API_URL'"
        
        # Validate required outputs
        if [ -z "$S3_BUCKET" ]; then
          echo "âŒ ERROR: S3 bucket name is empty!"
          echo "ðŸ” All available outputs:"
          terraform output -json || echo "No JSON outputs available"
          exit 1
        fi
        
        if [ -z "$WEBSITE_URL" ]; then
          echo "âŒ ERROR: Website URL is empty!"
          exit 1
        fi
        
        if [ -z "$API_URL" ]; then
          echo "âŒ ERROR: API URL is empty!"
          exit 1
        fi
        
        # Export to environment
        echo "S3_BUCKET=$S3_BUCKET" >> $GITHUB_ENV
        echo "WEBSITE_URL=$WEBSITE_URL" >> $GITHUB_ENV
        echo "API_URL=$API_URL" >> $GITHUB_ENV
        
        echo "âœ… All required outputs extracted successfully"

    - name: ðŸ“¤ Deploy Website
      if: github.event.inputs.action != 'destroy-only'
      run: |
        echo "ðŸ“¤ Deploying website files..."
        
        # Get outputs from Terraform with proper error handling
        cd infra/environments/dev
        
        # Extract outputs with proper quoting
        S3_BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
        API_URL=$(terraform output -raw api_url 2>/dev/null || echo "")
        WEBSITE_URL=$(terraform output -raw website_url 2>/dev/null || echo "")
        
        # Validate outputs exist
        if [[ -z "$S3_BUCKET" || -z "$API_URL" || -z "$WEBSITE_URL" ]]; then
          echo "âŒ ERROR: Missing required Terraform outputs"
          echo "S3_BUCKET: '$S3_BUCKET'"
          echo "API_URL: '$API_URL'"
          echo "WEBSITE_URL: '$WEBSITE_URL'"
          exit 1
        fi
        
        echo "ðŸ” Using S3 bucket: $S3_BUCKET"
        echo "ðŸ” Using API URL: $API_URL"
        echo "ðŸ” Using Website URL: $WEBSITE_URL"
        
        # Go back to project root
        cd ../../../
        
        # Verify website directory exists
        if [[ ! -d "website" ]]; then
          echo "âŒ ERROR: website directory not found"
          ls -la
          exit 1
        fi
        
        echo "âœ… Found website directory"
        ls -la website/
        
        # Update visitor counter with API URL
        echo "ðŸ”„ Updating visitor counter with API URL..."
        echo "ðŸ” API_URL variable contains: '$API_URL'"
        
        if [[ -f "website/js/visitor-counter.js" ]]; then
          # Verify API_URL is not empty
          if [[ -z "$API_URL" ]]; then
            echo "âŒ ERROR: API_URL is empty!"
            exit 1
          fi
          
          # Show original content
          echo "ðŸ“„ Original visitor-counter.js content (first 10 lines):"
          head -10 website/js/visitor-counter.js
          
          # Create backup
          cp website/js/visitor-counter.js website/js/visitor-counter.js.bak
          echo "âœ… Created backup: website/js/visitor-counter.js.bak"
          
          # âœ… ENHANCED: More robust replacement with error checking
          echo "ðŸ”„ Performing URL replacement..."
          if sed "s|REPLACE_WITH_API_URL|${API_URL}|g" website/js/visitor-counter.js.bak > website/js/visitor-counter.js; then
            echo "âœ… sed command executed successfully"
          else
            echo "âŒ sed command failed!"
            exit 1
          fi
          
          # Verify replacement worked
          if grep -q "REPLACE_WITH_API_URL" website/js/visitor-counter.js; then
            echo "âš ï¸ WARNING: API URL replacement failed - placeholder still exists!"
            echo "ðŸ” Lines containing REPLACE_WITH_API_URL:"
            grep -n "REPLACE_WITH_API_URL" website/js/visitor-counter.js || true
            echo "ðŸ” Full file content after replacement:"
            cat website/js/visitor-counter.js
            exit 1
          else
            echo "âœ… API URL replacement successful"
            echo "ðŸ” New API URL in file:"
            grep -n "apiUrl.*=" website/js/visitor-counter.js | head -1 || true
            echo "ðŸ” Verification - searching for the actual API URL:"
            grep -n "$API_URL" website/js/visitor-counter.js || echo "âš ï¸ API URL not found in file"
          fi
          
          # Show modified content
          echo "ðŸ“„ Modified visitor-counter.js content (first 10 lines):"
          head -10 website/js/visitor-counter.js
          
        else
          echo "âŒ ERROR: visitor-counter.js not found"
          echo "ðŸ” Current directory contents:"
          ls -la
          echo "ðŸ” Website directory contents:"
          ls -la website/ || echo "website/ directory not found"
          exit 1
        fi
        
        # Verify all required files exist
        required_files=(
          "website/index.html"
          "website/css/styles.css" 
          "website/js/visitor-counter.js"
        )
        
        for file in "${required_files[@]}"; do
          if [[ ! -f "$file" ]]; then
            echo "âŒ ERROR: Required file $file not found!"
            exit 1
          else
            echo "âœ… Found: $file"
          fi
        done
        
        # Upload website files to S3
        echo "ðŸš€ Uploading website files to S3..."
        
        # Sync all files first
        aws s3 sync website/ "s3://${S3_BUCKET}/" --delete
        
        # Set specific content types and cache headers
        echo "ðŸ”§ Setting content types and cache headers..."
        
        aws s3 cp website/index.html "s3://${S3_BUCKET}/index.html" \
          --content-type "text/html" \
          --cache-control "no-cache, no-store, must-revalidate"
          
        aws s3 cp website/css/styles.css "s3://${S3_BUCKET}/css/styles.css" \
          --content-type "text/css" \
          --cache-control "max-age=31536000"
          
        aws s3 cp website/js/visitor-counter.js "s3://${S3_BUCKET}/js/visitor-counter.js" \
          --content-type "application/javascript" \
          --cache-control "max-age=3600"
        
        # Upload animation.js if it exists
        if [[ -f "website/js/animation.js" ]]; then
          aws s3 cp website/js/animation.js "s3://${S3_BUCKET}/js/animation.js" \
            --content-type "application/javascript" \
            --cache-control "max-age=31536000"
          echo "âœ… Uploaded animation.js"
        fi
        
        # Restore original visitor-counter.js
        if [[ -f "website/js/visitor-counter.js.bak" ]]; then
          mv website/js/visitor-counter.js.bak website/js/visitor-counter.js
          echo "âœ… Restored original visitor-counter.js"
        fi
        
        echo "âœ… Website deployment completed successfully!"
        echo "ðŸŒ Website available at: $WEBSITE_URL"
        
        # Test the deployment
        echo "ðŸ§ª Testing API endpoint..."
        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL" || echo "000")
        if [[ "$HTTP_STATUS" == "200" ]]; then
          echo "âœ… API endpoint is responding correctly"
        else
          echo "âš ï¸ API endpoint returned status: $HTTP_STATUS"
        fi
        
        echo "ðŸŽ‰ Deployment completed! Visit your resume at: $WEBSITE_URL"

    - name: ðŸ› Debug Lambda Function
      if: github.event.inputs.action != 'destroy-only'
      run: |
        echo "ðŸ” Debugging Lambda function..."
        
        # Get Lambda function name and details
        cd infra/environments/dev
        LAMBDA_NAME=$(terraform output -raw lambda_function_name 2>/dev/null || echo "")
        cd ../../../
        
        if [ ! -z "$LAMBDA_NAME" ]; then
          echo "ðŸ“‹ Lambda function: $LAMBDA_NAME"
          
          # Check Lambda configuration
          echo "ðŸ” Lambda configuration:"
          aws lambda get-function-configuration --function-name "$LAMBDA_NAME"
          
          # Test the Lambda function directly
          echo "ðŸ§ª Testing Lambda function directly..."
          aws lambda invoke \
            --function-name "$LAMBDA_NAME" \
            --payload '{}' \
            --output json \
            lambda_response.json
            
          echo "ðŸ“„ Lambda direct response:"
          cat lambda_response.json
          
          # Check recent logs
          echo "ðŸ“Š Recent CloudWatch logs (last 5 minutes):"
          LOG_GROUP="/aws/lambda/$LAMBDA_NAME"
          aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --query 'logGroups[0].logGroupName' --output text | \
          xargs -I {} aws logs filter-log-events --log-group-name {} --start-time $(date -d '5 minutes ago' +%s)000 --query 'events[].message' --output text || echo "No recent logs found"
        else
          echo "âŒ Could not find Lambda function name"
        fi

    - name: ðŸ§ª Test Deployment
      if: github.event.inputs.action != 'destroy-only'
      run: |
        echo "ðŸ§ª Testing deployed resume..."
        sleep 30  # Reduced wait time
        
        # Test website
        echo "Testing website..."
        if curl -f -s "$WEBSITE_URL" > /dev/null; then
          echo "âœ… Website is accessible"
        else
          echo "âš ï¸ Website test failed"
        fi
        
        # Test API endpoint
        echo "Testing API endpoint: $API_URL"
        response=$(curl -s "$API_URL" 2>/dev/null || echo '{"error":"request_failed"}')
        echo "ðŸ” API Response: $response"
        
        # Check if API returns expected format
        if echo "$response" | grep -q "visitor_count"; then
          echo "âœ… Visitor counter API is working correctly"
          visitor_count=$(echo "$response" | grep -o '"visitor_count":[0-9]*' | cut -d':' -f2)
          echo "ðŸ“Š Current visitor count: $visitor_count"
        else
          echo "âš ï¸ API test: Unexpected response format"
          echo "Expected: {\"visitor_count\": number}"
          echo "Got: $response"
        fi

    - name: ðŸ“Š Summary
      if: github.event.inputs.action != 'destroy-only'
      run: |
        echo "## â˜ï¸ Cloud Resume Deployment" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**ðŸŒ Live Website:** [$WEBSITE_URL]($WEBSITE_URL)" >> $GITHUB_STEP_SUMMARY
        echo "**âš¡ Visitor Counter API:** [$API_URL]($API_URL)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # âœ… FIX: Use correct input parameter name
        keep_minutes="${{ github.event.inputs.keep_alive_minutes || '5' }}"
        if [ "${{ github.event.inputs.action }}" = "deploy-test-destroy" ]; then
          echo "â° **Auto-cleanup scheduled in $keep_minutes minute(s)**" >> $GITHUB_STEP_SUMMARY
        else
          echo "âœ… **Status:** Deployed and running" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”— Quick Links" >> $GITHUB_STEP_SUMMARY
        echo "- **Website**: [Visit Resume]($WEBSITE_URL)" >> $GITHUB_STEP_SUMMARY
        echo "- **API Test**: [Test Visitor Counter]($API_URL)" >> $GITHUB_STEP_SUMMARY

    - name: â³ Keep Running (Demo Period)
      if: github.event.inputs.action == 'deploy-test-keep' || github.event.inputs.action == 'deploy-test-destroy'
      run: |
        # âœ… FIX: Use minutes instead of hours to match input parameter
        minutes="${{ github.event.inputs.keep_alive_minutes || '1' }}"
        echo "â³ Keeping resume live for $minutes minute(s) for demo/testing..."
        echo "ðŸŒ Visit: $WEBSITE_URL"
        sleep $(($minutes * 60))  # Convert minutes to seconds

    - name: ðŸ—‘ï¸ Cleanup
      if: always() && (github.event.inputs.action == 'deploy-test-destroy' || github.event.inputs.action == 'destroy-only')
      working-directory: ./infra/environments/dev
      run: |
        echo "ðŸ—‘ï¸ Cleaning up resources..."
        
        # Get bucket name if we need to
        if [ "${{ github.event.inputs.action }}" = "destroy-only" ]; then
          S3_BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
        fi
        
        # Empty S3 bucket
        if [ ! -z "$S3_BUCKET" ]; then
          echo "ðŸª£ Emptying S3 bucket..."
          aws s3 rm s3://$S3_BUCKET --recursive || true
        fi
        
        # Destroy infrastructure
        terraform destroy -auto-approve || true
        echo "âœ… Cleanup completed!"