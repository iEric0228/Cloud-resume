name: 'â˜ï¸ Cloud Resume CI/CD'

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Deployment Action'
        required: true
        default: 'deploy-test-destroy'
        type: choice
        options:
          - 'deploy-test-destroy'
          - 'deploy-test-keep'  
          - 'destroy-only'
      keep_alive_minutes:
        description: 'Keep alive time (minutes) for testing'
        required: false
        default: '5'
        type: string

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.6.0

jobs:
  # Validation job (runs on PRs)
  validate:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
    - name: ğŸš€ Checkout Code
      uses: actions/checkout@v4

    - name: âš¡ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: ğŸ” Validate Everything
      run: |
        # Terraform validation
        cd infra/environments/dev
        terraform init
        terraform validate
        terraform fmt -check
        echo "âœ… Terraform validation passed"
        
        # Website validation
        cd ../../../
        required_files=("website/index.html" "website/css/styles.css" "website/js/visitor-counter.js")
        for file in "${required_files[@]}"; do
          [[ -f "$file" ]] && echo "âœ… $file" || { echo "âŒ Missing $file"; exit 1; }
        done
        echo "âœ… Website files validation passed"

  # Main deploy job (runs on manual dispatch)
  deploy-resume:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
    - name: ğŸš€ Checkout Code
      uses: actions/checkout@v4

    - name: âš¡ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        terraform_wrapper: false

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::125156866057:role/github-OICD
        role-session-name: cloud-resume-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Deploy Infrastructure
      if: github.event.inputs.action != 'destroy-only'
      working-directory: ./infra/environments/dev
      run: |
        echo "ğŸš€ Deploying cloud resume infrastructure..."
        terraform init
        
        echo "ğŸ” Checking for existing resources..."
        
        # âœ… ENHANCED: More robust import with state checking
        echo "ğŸ‘¥ Checking IAM role..."
        if terraform state show module.lambda.aws_iam_role.lambda_role 2>/dev/null; then
          echo "âœ… IAM role already in Terraform state"
        elif aws iam get-role --role-name cloud-resume-lambda-role-dev 2>/dev/null; then
          echo "ğŸ“‹ IAM role exists in AWS, importing to Terraform state..."
          terraform import module.lambda.aws_iam_role.lambda_role cloud-resume-lambda-role-dev || {
            echo "âš ï¸ IAM role import failed, will try to recreate"
            # Delete the existing role to allow recreation
            echo "ğŸ—‘ï¸ Removing existing IAM role to allow recreation..."
            aws iam list-attached-role-policies --role-name cloud-resume-lambda-role-dev --query "AttachedPolicies[].PolicyArn" --output text | tr '\t' '\n' | \
            xargs -r -I {} aws iam detach-role-policy --role-name cloud-resume-lambda-role-dev --policy-arn {}
            
            aws iam list-role-policies --role-name cloud-resume-lambda-role-dev --query "PolicyNames" --output text | tr '\t' '\n' | \
            xargs -r -I {} aws iam delete-role-policy --role-name cloud-resume-lambda-role-dev --policy-name {}
            
            aws iam delete-role --role-name cloud-resume-lambda-role-dev
            echo "âœ… Existing IAM role cleaned up"
          }
        else
          echo "ğŸ‘¥ IAM role doesn't exist, will create new one"
        fi
        
        echo "ğŸ“‹ Checking IAM role policy..."
        if terraform state show module.lambda.aws_iam_role_policy.lambda_policy 2>/dev/null; then
          echo "âœ… IAM role policy already in Terraform state"
        elif aws iam get-role-policy --role-name cloud-resume-lambda-role-dev --policy-name cloud-resume-lambda-policy-dev 2>/dev/null; then
          echo "ğŸ“‹ IAM role policy exists, importing to Terraform state..."
          terraform import module.lambda.aws_iam_role_policy.lambda_policy cloud-resume-lambda-role-dev:cloud-resume-lambda-policy-dev || {
            echo "âš ï¸ IAM role policy import failed or already in state"
          }
        else
          echo "ğŸ“‹ IAM role policy doesn't exist, will create new one"
        fi
        
        # Check and import DynamoDB table
        echo "ğŸ“Š Checking DynamoDB table..."
        if terraform state show module.dynamodb.aws_dynamodb_table.visitor_count 2>/dev/null; then
          echo "âœ… DynamoDB table already in Terraform state"
        elif aws dynamodb describe-table --table-name cloud-resume-visitor-count-dev 2>/dev/null; then
          echo "ğŸ“‹ DynamoDB table exists, importing to Terraform state..."
          terraform import module.dynamodb.aws_dynamodb_table.visitor_count cloud-resume-visitor-count-dev || {
            echo "âš ï¸ Table import failed or already in state"
          }
        else
          echo "ğŸ“‹ DynamoDB table doesn't exist, will create new one"
        fi
        
        # Plan and apply
        echo "ğŸ“‹ Planning deployment..."
        terraform plan
        terraform apply -auto-approve
        
        echo "ğŸ” Debug: Available Terraform outputs:"
        terraform output || echo "âŒ No outputs available"
        
        # Export outputs with better error handling
        S3_BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
        WEBSITE_URL=$(terraform output -raw website_url 2>/dev/null || echo "")  
        API_URL=$(terraform output -raw api_url 2>/dev/null || echo "")
        
        echo "ğŸ” Debug: Extracted values:"
        echo "S3_BUCKET='$S3_BUCKET'"
        echo "WEBSITE_URL='$WEBSITE_URL'"
        echo "API_URL='$API_URL'"
        
        # Validate required outputs
        if [ -z "$S3_BUCKET" ]; then
          echo "âŒ ERROR: S3 bucket name is empty!"
          echo "ğŸ” All available outputs:"
          terraform output -json || echo "No JSON outputs available"
          exit 1
        fi
        
        if [ -z "$WEBSITE_URL" ]; then
          echo "âŒ ERROR: Website URL is empty!"
          exit 1
        fi
        
        if [ -z "$API_URL" ]; then
          echo "âŒ ERROR: API URL is empty!"
          exit 1
        fi
        
        # Export to environment
        echo "S3_BUCKET=$S3_BUCKET" >> $GITHUB_ENV
        echo "WEBSITE_URL=$WEBSITE_URL" >> $GITHUB_ENV
        echo "API_URL=$API_URL" >> $GITHUB_ENV
        
        echo "âœ… All required outputs extracted successfully"

    - name: ğŸ“¤ Deploy Website
      if: github.event.inputs.action != 'destroy-only'
      run: |
        echo "ğŸ“¤ Deploying website files..."
        
        # Get outputs from Terraform with proper error handling
        cd infra/environments/dev
        
        # Extract outputs with proper quoting
        S3_BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
        API_URL=$(terraform output -raw api_url 2>/dev/null || echo "")
        WEBSITE_URL=$(terraform output -raw website_url 2>/dev/null || echo "")
        
        # Validate outputs exist
        if [[ -z "$S3_BUCKET" || -z "$API_URL" || -z "$WEBSITE_URL" ]]; then
          echo "âŒ ERROR: Missing required Terraform outputs"
          echo "S3_BUCKET: '$S3_BUCKET'"
          echo "API_URL: '$API_URL'"
          echo "WEBSITE_URL: '$WEBSITE_URL'"
          exit 1
        fi
        
        echo "ğŸ” Using S3 bucket: $S3_BUCKET"
        echo "ğŸ” Using API URL: $API_URL"
        echo "ğŸ” Using Website URL: $WEBSITE_URL"
        
        # Go back to project root
        cd ../../../
        
        # Verify website directory exists
        if [[ ! -d "website" ]]; then
          echo "âŒ ERROR: website directory not found"
          ls -la
          exit 1
        fi
        
        echo "âœ… Found website directory"
        ls -la website/
        
        # Update visitor counter with API URL
        echo "ğŸ”„ Updating visitor counter with API URL..."
        echo "ğŸ” API_URL variable contains: '$API_URL'"
        
        if [[ -f "website/js/visitor-counter.js" ]]; then
          # Verify API_URL is not empty
          if [[ -z "$API_URL" ]]; then
            echo "âŒ ERROR: API_URL is empty!"
            exit 1
          fi
          
          # Show original content
          echo "ğŸ“„ Original visitor-counter.js content (first 10 lines):"
          head -10 website/js/visitor-counter.js
          
          # Create backup
          cp website/js/visitor-counter.js website/js/visitor-counter.js.bak
          echo "âœ… Created backup: website/js/visitor-counter.js.bak"
          
          # âœ… ENHANCED: More precise replacement - only replace the assignment line
          echo "ğŸ”„ Performing URL replacement..."
          sed "s|this\.apiUrl = 'REPLACE_WITH_API_URL'|this.apiUrl = '${API_URL}'|g" website/js/visitor-counter.js.bak > website/js/visitor-counter.js
          
          echo "âœ… sed command executed successfully"
          
          # Verify replacement worked
          if grep -q "REPLACE_WITH_API_URL" website/js/visitor-counter.js; then
            echo "âš ï¸ WARNING: Some REPLACE_WITH_API_URL placeholders still exist"
            echo "ğŸ” Lines containing REPLACE_WITH_API_URL:"
            grep -n "REPLACE_WITH_API_URL" website/js/visitor-counter.js || true
            
            # Check if assignment was replaced correctly
            if grep -q "this\.apiUrl = '${API_URL}'" website/js/visitor-counter.js; then
              echo "âœ… Assignment replacement successful (some placeholders remain for logic)"
            else
              echo "âŒ Assignment replacement failed!"
              exit 1
            fi
          else
            echo "âœ… All placeholders replaced"
          fi
          
          # Show modified content
          echo "ğŸ“„ Modified visitor-counter.js content (first 10 lines):"
          head -10 website/js/visitor-counter.js
          
        else
          echo "âŒ ERROR: visitor-counter.js not found"
          echo "ğŸ” Current directory contents:"
          ls -la
          echo "ğŸ” Website directory contents:"
          ls -la website/ || echo "website/ directory not found"
          exit 1
        fi
        
        # Verify all required files exist
        required_files=(
          "website/index.html"
          "website/css/styles.css" 
          "website/js/visitor-counter.js"
        )
        
        for file in "${required_files[@]}"; do
          if [[ ! -f "$file" ]]; then
            echo "âŒ ERROR: Required file $file not found!"
            exit 1
          else
            echo "âœ… Found: $file"
          fi
        done
        
        # Upload website files to S3
        echo "ğŸš€ Uploading website files to S3..."
        
        # Sync all files first
        aws s3 sync website/ "s3://${S3_BUCKET}/" --delete
        
        # Set specific content types and cache headers
        echo "ğŸ”§ Setting content types and cache headers..."
        
        aws s3 cp website/index.html "s3://${S3_BUCKET}/index.html" \
          --content-type "text/html" \
          --cache-control "no-cache, no-store, must-revalidate"
          
        aws s3 cp website/css/styles.css "s3://${S3_BUCKET}/css/styles.css" \
          --content-type "text/css" \
          --cache-control "max-age=31536000"
          
        # âœ… FIX: Upload the MODIFIED visitor-counter.js (with real API URL)
        aws s3 cp website/js/visitor-counter.js "s3://${S3_BUCKET}/js/visitor-counter.js" \
          --content-type "application/javascript" \
          --cache-control "max-age=300"
        
        # Upload animation.js if it exists
        if [[ -f "website/js/animation.js" ]]; then
          aws s3 cp website/js/animation.js "s3://${S3_BUCKET}/js/animation.js" \
            --content-type "application/javascript" \
            --cache-control "max-age=31536000"
          echo "âœ… Uploaded animation.js"
        fi
        
        echo "âœ… Website files uploaded to S3 successfully!"
        
        # âœ… ADD: Invalidate CloudFront cache for JavaScript files
        echo "ğŸ”„ Invalidating CloudFront cache..."
        cd infra/environments/dev
        CLOUDFRONT_ID=$(terraform output -raw cloudfront_distribution_id 2>/dev/null || echo "")
        cd ../../../
        
        if [ ! -z "$CLOUDFRONT_ID" ]; then
          echo "â˜ï¸ Invalidating CloudFront distribution: $CLOUDFRONT_ID"
          aws cloudfront create-invalidation \
            --distribution-id "$CLOUDFRONT_ID" \
            --paths "/js/visitor-counter.js" "/js/*" "/*" \
            --query 'Invalidation.Id' \
            --output text
          echo "âœ… CloudFront cache invalidated"
        else
          echo "âš ï¸ CloudFront distribution ID not found, skipping cache invalidation"
        fi
        
        # âœ… FIX: NOW restore original visitor-counter.js (AFTER uploading AND invalidating)
        if [[ -f "website/js/visitor-counter.js.bak" ]]; then
          mv website/js/visitor-counter.js.bak website/js/visitor-counter.js
          echo "âœ… Restored original visitor-counter.js for git cleanliness"
        fi
        
        echo "âœ… Website deployment completed successfully!"
        echo "ğŸŒ Website available at: $WEBSITE_URL"
        
        # Test the deployment
        echo "ğŸ§ª Testing API endpoint..."
        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL" || echo "000")
        if [[ "$HTTP_STATUS" == "200" ]]; then
          echo "âœ… API endpoint is responding correctly"
        else
          echo "âš ï¸ API endpoint returned status: $HTTP_STATUS"
        fi
        
        echo "ğŸ‰ Deployment completed! Visit your resume at: $WEBSITE_URL"

    - name: ğŸ› Debug Lambda Function
      if: github.event.inputs.action != 'destroy-only'
      run: |
        echo "ğŸ” Debugging Lambda function..."
        
        # Get Lambda function name and details
        cd infra/environments/dev
        LAMBDA_NAME=$(terraform output -raw lambda_function_name 2>/dev/null || echo "")
        cd ../../../
        
        if [ ! -z "$LAMBDA_NAME" ]; then
          echo "ğŸ“‹ Lambda function: $LAMBDA_NAME"
          
          # Check Lambda configuration
          echo "ğŸ” Lambda configuration:"
          aws lambda get-function-configuration --function-name "$LAMBDA_NAME"
          
          # Test the Lambda function directly
          echo "ğŸ§ª Testing Lambda function directly..."
          aws lambda invoke \
            --function-name "$LAMBDA_NAME" \
            --payload '{}' \
            --output json \
            lambda_response.json
            
          echo "ğŸ“„ Lambda direct response:"
          cat lambda_response.json
          
          # Check recent logs
          echo "ğŸ“Š Recent CloudWatch logs (last 5 minutes):"
          LOG_GROUP="/aws/lambda/$LAMBDA_NAME"
          aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --query 'logGroups[0].logGroupName' --output text | \
          xargs -I {} aws logs filter-log-events --log-group-name {} --start-time $(date -d '5 minutes ago' +%s)000 --query 'events[].message' --output text || echo "No recent logs found"
        else
          echo "âŒ Could not find Lambda function name"
        fi

    - name: ğŸ§ª Test Deployment
      if: github.event.inputs.action != 'destroy-only'
      run: |
        echo "ğŸ§ª Testing deployed resume..."
        sleep 30  # Reduced wait time
        
        # Test website
        echo "Testing website..."
        if curl -f -s "$WEBSITE_URL" > /dev/null; then
          echo "âœ… Website is accessible"
        else
          echo "âš ï¸ Website test failed"
        fi
        
        # Test API endpoint
        echo "Testing API endpoint: $API_URL"
        response=$(curl -s "$API_URL" 2>/dev/null || echo '{"error":"request_failed"}')
        echo "ğŸ” API Response: $response"
        
        # Check if API returns expected format
        if echo "$response" | grep -q "visitor_count"; then
          echo "âœ… Visitor counter API is working correctly"
          visitor_count=$(echo "$response" | grep -o '"visitor_count":[0-9]*' | cut -d':' -f2)
          echo "ğŸ“Š Current visitor count: $visitor_count"
        else
          echo "âš ï¸ API test: Unexpected response format"
          echo "Expected: {\"visitor_count\": number}"
          echo "Got: $response"
        fi

    - name: ğŸ“Š Summary
      if: github.event.inputs.action != 'destroy-only'
      run: |
        echo "## â˜ï¸ Cloud Resume Deployment" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**ğŸŒ Live Website:** [$WEBSITE_URL]($WEBSITE_URL)" >> $GITHUB_STEP_SUMMARY
        echo "**âš¡ Visitor Counter API:** [$API_URL]($API_URL)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # âœ… FIX: Use correct input parameter name
        keep_minutes="${{ github.event.inputs.keep_alive_minutes || '5' }}"
        if [ "${{ github.event.inputs.action }}" = "deploy-test-destroy" ]; then
          echo "â° **Auto-cleanup scheduled in $keep_minutes minute(s)**" >> $GITHUB_STEP_SUMMARY
        else
          echo "âœ… **Status:** Deployed and running" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ğŸ”— Quick Links" >> $GITHUB_STEP_SUMMARY
        echo "- **Website**: [Visit Resume]($WEBSITE_URL)" >> $GITHUB_STEP_SUMMARY
        echo "- **API Test**: [Test Visitor Counter]($API_URL)" >> $GITHUB_STEP_SUMMARY

    - name: â³ Keep Running (Demo Period)
      if: github.event.inputs.action == 'deploy-test-keep' || github.event.inputs.action == 'deploy-test-destroy'
      run: |
        # âœ… FIX: Use minutes instead of hours to match input parameter
        minutes="${{ github.event.inputs.keep_alive_minutes || '1' }}"
        echo "â³ Keeping resume live for $minutes minute(s) for demo/testing..."
        echo "ğŸŒ Visit: $WEBSITE_URL"
        sleep $(($minutes * 60))  # Convert minutes to seconds

    - name: ğŸ—‘ï¸ Cleanup
      if: always() && (github.event.inputs.action == 'deploy-test-destroy' || github.event.inputs.action == 'destroy-only')
      working-directory: ./infra/environments/dev
      run: |
        echo "ğŸ—‘ï¸ Cleaning up resources..."
        
        # Get bucket name if we need to
        if [ "${{ github.event.inputs.action }}" = "destroy-only" ]; then
          S3_BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
        fi
        
        # âœ… ENHANCED: Complete S3 bucket cleanup including versions
        if [ ! -z "$S3_BUCKET" ]; then
          echo "ğŸª£ Emptying S3 bucket completely..."
          
          # Delete all object versions and delete markers
          echo "ğŸ—‘ï¸ Deleting all object versions..."
          aws s3api list-object-versions --bucket "$S3_BUCKET" --output json | \
          jq -r '.Versions[]? | "\(.Key) \(.VersionId)"' | \
          while read key version_id; do
            if [ ! -z "$key" ] && [ ! -z "$version_id" ]; then
              echo "   Deleting version: $key ($version_id)"
              aws s3api delete-object --bucket "$S3_BUCKET" --key "$key" --version-id "$version_id" || true
            fi
          done
          
          # Delete all delete markers
          echo "ğŸ—‘ï¸ Deleting all delete markers..."
          aws s3api list-object-versions --bucket "$S3_BUCKET" --output json | \
          jq -r '.DeleteMarkers[]? | "\(.Key) \(.VersionId)"' | \
          while read key version_id; do
            if [ ! -z "$key" ] && [ ! -z "$version_id" ]; then
              echo "   Deleting delete marker: $key ($version_id)"
              aws s3api delete-object --bucket "$S3_BUCKET" --key "$key" --version-id "$version_id" || true
            fi
          done
          
          # Final cleanup with recursive delete
          echo "ğŸ—‘ï¸ Final recursive delete..."
          aws s3 rm s3://$S3_BUCKET --recursive || true
          
          # Force empty bucket using sync
          echo "ğŸ—‘ï¸ Force emptying bucket with sync..."
          mkdir -p /tmp/empty-bucket
          aws s3 sync /tmp/empty-bucket s3://$S3_BUCKET --delete || true
          
          echo "âœ… S3 bucket emptied completely"
        else
          echo "âš ï¸ No S3 bucket found to clean up"
        fi
        
        # Destroy infrastructure
        echo "ğŸ”¨ Destroying Terraform infrastructure..."
        terraform destroy -auto-approve || true
        echo "âœ… Cleanup completed!"